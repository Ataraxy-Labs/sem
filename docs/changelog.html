<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sem &mdash; Changelog</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0a;
      --fg: #e0e0e0;
      --dim: #666;
      --dim2: #444;
      --border: #222;
      --accent: #fff;
      --green: #e0e0e0;
      --yellow: #999;
      --red: #888;
      --blue: #ccc;
      --cyan: #bbb;
      --purple: #aaa;
      --orange: #999;
      --surface: #111;
      --surface2: #141414;
      --mono: 'SF Mono', 'Cascadia Code', 'Fira Code', 'JetBrains Mono', monospace;
    }

    body {
      font-family: var(--mono);
      background: var(--bg);
      color: var(--fg);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
    }

    a { color: var(--fg); text-decoration-color: var(--dim); text-underline-offset: 3px; }
    a:hover { color: var(--accent); text-decoration-color: var(--accent); }

    .container { max-width: 800px; margin: 0 auto; padding: 0 24px; }

    /* Nav */
    nav {
      padding: 20px 0;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      background: var(--bg);
      z-index: 50;
    }
    nav .logo { font-size: 18px; font-weight: 700; letter-spacing: -0.5px; color: var(--accent); text-decoration: none; }
    nav .logo:hover { color: var(--accent); }
    nav .links { display: flex; gap: 20px; font-size: 13px; color: var(--dim); }

    /* Sections */
    section { padding: 60px 0; }
    section h2 {
      font-size: 22px; font-weight: 600; color: var(--accent);
      margin-bottom: 12px; letter-spacing: -0.5px;
    }
    section .section-desc {
      font-size: 14px; color: var(--dim); margin-bottom: 32px; line-height: 1.7;
    }

    /* Changelog */
    .changelog-entry { padding: 20px 0; border-bottom: 1px solid #181818; }
    .changelog-entry:last-child { border-bottom: none; }
    .changelog-sha {
      font-size: 12px; color: var(--cyan); background: var(--surface);
      padding: 2px 8px; border-radius: 4px; margin-right: 8px;
    }
    .changelog-tag {
      font-size: 11px; padding: 2px 8px; border-radius: 4px; margin-right: 6px;
    }
    .changelog-tag.feat { background: #1a1a1a; color: var(--fg); }
    .changelog-tag.perf { background: #1a1a1a; color: var(--fg); }
    .changelog-tag.fix { background: #1a1a1a; color: var(--fg); }
    .changelog-tag.rewrite { background: #1a1a1a; color: var(--fg); }
    .changelog-tag.docs { background: #1a1a1a; color: var(--fg); }
    .changelog-title { font-size: 14px; color: var(--accent); font-weight: 600; margin-bottom: 6px; }
    .changelog-body { font-size: 12px; color: var(--dim); line-height: 1.7; }
    .changelog-stats { font-size: 11px; color: var(--dim2); margin-top: 8px; }
    .changelog-mistake {
      margin-top: 10px; padding: 10px 14px; border-left: 2px solid #555;
      background: #141414; font-size: 12px; color: var(--dim); line-height: 1.6;
    }
    .changelog-mistake strong { color: var(--accent); font-weight: 600; }

    /* Footer */
    footer {
      padding: 40px 0; border-top: 1px solid var(--border);
      text-align: center; font-size: 12px; color: var(--dim);
    }

    @media (max-width: 640px) {
      nav .links { gap: 12px; font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <nav>
      <a href="index.html" class="logo">sem</a>
      <div class="links">
        <a href="index.html#commands">Commands</a>
        <a href="index.html#formats">Formats</a>
        <a href="index.html#output">Output</a>
        <a href="index.html#benchmarks">Benchmarks</a>
        <a href="agents.html">Agents</a>
        <a href="changelog.html">Changelog</a>
        <a href="https://github.com/Ataraxy-Labs/sem">GitHub</a>
        <a href="llms.txt">llms.txt</a>
      </div>
    </nav>

    <section>
      <h2>Changelog</h2>
      <p class="section-desc">
        How sem evolved &mdash; including the mistakes.
      </p>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">59f40ed</span>
          <span class="changelog-tag feat">feat</span>
          v0.3.1: --file-exts flag for language filtering
        </div>
        <p class="changelog-body">
          New <code style="color:var(--fg)">--file-exts</code> flag on <code style="color:var(--fg)">sem diff</code>, <code style="color:var(--fg)">sem graph</code>, and <code style="color:var(--fg)">sem impact</code>.
          Lets you scope analysis to specific languages in multi-language repos.
          Example: <code style="color:var(--fg)">sem graph --file-exts .py</code> to build the dependency graph for Python files only.
          Accepts extensions with or without the leading dot. First feature shipped from a community request (<a href="https://github.com/Ataraxy-Labs/sem/issues/1" style="color:var(--cyan)">#1</a>).
        </p>
        <p class="changelog-stats">+63 lines &bull; 4 files &bull; diff, graph, impact commands &bull; closes #1</p>
      </div>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">f1cf19a</span>
          <span class="changelog-tag perf">perf</span>
          Incremental graph updates
        </div>
        <p class="changelog-body">
          <code style="color:var(--fg)">EntityGraph::update_from_changes()</code> incrementally updates the dependency graph when files change, instead of rebuilding from scratch.
          Handles Added, Modified, Deleted, and Renamed files. Re-extracts only changed files, rebuilds symbol table, re-resolves references.
          Much faster than full rebuild on large repos when only a few files changed.
        </p>
        <p class="changelog-stats">+444 lines &bull; 3 files &bull; 4 new tests &bull; 18 total tests passing</p>
      </div>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">da9f34f</span>
          <span class="changelog-tag feat">feat</span>
          sem impact: change impact analysis
        </div>
        <p class="changelog-body">
          New <code style="color:var(--fg)">sem impact &lt;entity_name&gt;</code> command shows transitive dependents &mdash; what would break if you changed an entity.
          Uses BFS over the entity dependency graph. Output grouped by file, with <code style="color:var(--fg)">--json</code> flag for machine consumption.
          Shows the blast radius at every depth level: direct dependents, their dependents, and so on.
        </p>
        <p class="changelog-stats">+177 lines &bull; 4 files &bull; terminal + JSON output</p>
      </div>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">e6dd39f</span>
          <span class="changelog-tag feat">feat</span>
          Structural hash + entity dependency graph
        </div>
        <p class="changelog-body">
          Two major features. <strong>Structural hash</strong> (Unison-inspired): computes AST-based hash that strips comments and normalizes whitespace. Two entities with the same structural_hash are logically identical even if formatting differs. Used for rename detection.
          <strong>Entity dependency graph</strong>: two-pass extraction (entities &rarr; symbol table &rarr; reference edges). Intra-file and cross-file resolution. Forward + reverse dependency lookup. Transitive impact analysis via BFS.
          New <code style="color:var(--fg)">sem graph</code> CLI command.
        </p>
        <p class="changelog-stats">+749 lines &bull; 15 files &bull; 14 tests (up from 10) &bull; structural_hash, EntityGraph, sem graph, sem impact</p>
        <div class="changelog-mistake">
          <strong>Lesson: two-pass extraction is key.</strong> You can't resolve references in a single pass because forward declarations aren't available yet. Building the full symbol table first (name &rarr; entity ID), then resolving references in a second pass, is the same approach compilers use. Obvious in hindsight, but the first attempt tried single-pass and produced broken edges for every forward reference.
        </div>
      </div>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">01edf1f</span>
          <span class="changelog-tag feat">feat</span>
          Initial release
        </div>
        <p class="changelog-body">
          First working version. <code style="color:var(--fg)">sem diff</code> with tree-sitter parsing for TypeScript, JavaScript, Python, Go, Rust.
          JSON/YAML/TOML/CSV/Markdown support via custom parsers. Three-phase entity matching (exact ID, content hash, fuzzy similarity).
        </p>
        <p class="changelog-stats">Node.js + TypeScript &bull; tsup build &bull; better-sqlite3 for storage &bull; ~290ms cold start</p>
        <div class="changelog-mistake">
          <strong>Mistake: Node.js startup overhead.</strong> The entire runtime &mdash; V8 init, module resolution, dynamic imports of tree-sitter WASM binaries &mdash; took ~120ms before any real work began. For a CLI tool that should feel instant, this was a problem we didn't think about until we started measuring.
        </div>
      </div>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">9f7f1c7</span>
          <span class="changelog-tag feat">feat</span>
          7 new commands
        </div>
        <p class="changelog-body">
          Added <code style="color:var(--fg)">blame</code>, <code style="color:var(--fg)">status</code>, <code style="color:var(--fg)">watch</code>, <code style="color:var(--fg)">review</code>, <code style="color:var(--fg)">history</code>, <code style="color:var(--fg)">label</code>, <code style="color:var(--fg)">comment</code>.
          Entity-level blame (who last touched each function), semantic PR review with risk signals, real-time file watching, threaded comments on entities.
        </p>
        <p class="changelog-stats">+1,191 lines &bull; 12 files &bull; 15 functions, 12 interfaces, 3 variables, 1 class added</p>
      </div>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">fffb38f</span>
          <span class="changelog-tag perf">perf</span>
          591ms &rarr; 260ms (56% faster)
        </div>
        <p class="changelog-body">
          Parallelized git operations. Replaced sequential <code style="color:var(--fg)">simple-git</code> calls with batched <code style="color:var(--fg)">diff --name-status</code> + <code style="color:var(--fg)">show</code>. Lazy-loaded parsers instead of importing all grammars upfront. Added internal benchmarking harness.
        </p>
        <p class="changelog-stats">+705 lines &bull; 32 added, 10 modified, 3 deleted entities across 5 types</p>
        <div class="changelog-mistake">
          <strong>Mistake: optimizing the wrong layer.</strong> We spent a week shaving milliseconds off the Node.js implementation &mdash; lazy imports, worker threads, caching git objects. Got from 591ms to 260ms, which felt like a win. But 120ms of that was still V8 startup that no amount of application-level optimization could touch. The real fix was switching runtimes entirely.
        </div>
      </div>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">ae576ab</span>
          <span class="changelog-tag rewrite">rewrite</span>
          Rust rewrite: 30ms (10x faster)
        </div>
        <p class="changelog-body">
          Rewrote <code style="color:var(--fg)">sem diff</code> as a compiled Rust binary. git2 for in-process git operations (no subprocess spawning), tree-sitter grammars compiled directly into the binary (no WASM, no dynamic loading).
          Cargo workspace: <code style="color:var(--fg)">sem-core</code> (library) + <code style="color:var(--fg)">sem-cli</code> (binary). All 7 parser plugins ported.
        </p>
        <p class="changelog-stats">+3,905 lines &bull; 278 entities &bull; 11 entity types including Rust-specific (struct, impl, trait)</p>
        <div class="changelog-mistake">
          <strong>Lesson: where the time actually goes.</strong> Node.js breakdown: ~120ms V8 startup, ~80ms module resolution, ~50ms WASM grammar load, ~40ms git subprocess spawn.
          Rust breakdown: ~3ms binary load, ~5ms git2 repo open, ~17ms parse + match. The entire Rust binary finishes before Node even loads its first module.
          We should have started in Rust &mdash; but building in Node first let us iterate on the algorithm fast, and the Rust port was straightforward because the architecture was already proven.
        </div>
      </div>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">bench</span>
          <span class="changelog-tag docs">bench</span>
          Agent accuracy benchmark
        </div>
        <p class="changelog-body">
          Proved that AI agents are 2.3x more accurate at answering questions about code changes when given <code style="color:var(--fg)">sem diff</code> JSON vs raw <code style="color:var(--fg)">git diff</code> output.
          Tested with Claude Sonnet 4.5 across 4 question types and 3 commits of varying size.
          Core finding: line diffs cause systematic failures &mdash; the model confuses lines with entities, can't distinguish adds from modifications, and has no entity type vocabulary.
        </p>
        <p class="changelog-stats">24 API calls &bull; sem 95.9% avg accuracy vs git 41.5% &bull; +54.4% delta</p>
      </div>

      <div class="changelog-entry">
        <div class="changelog-title">
          <span class="changelog-sha">next</span>
          <span class="changelog-tag feat">feat</span>
          Homebrew distribution
        </div>
        <p class="changelog-body">
          <code style="color:var(--fg)">brew install sem-diff</code> &mdash; single command install via Homebrew tap.
          Formula builds from source using Cargo, compiles all tree-sitter grammars in, links against system libgit2.
          Includes a test that verifies entity extraction on a Python function.
        </p>
        <p class="changelog-stats">3 install methods: Homebrew (recommended) &bull; curl installer &bull; cargo install from source</p>
        <div class="changelog-mistake">
          <strong>Lesson: distribution matters as much as the tool.</strong> A fast binary that's hard to install doesn't get adopted.
          We started with <code style="color:var(--dim)">npm install -g</code>, then a curl script, and finally Homebrew.
          Each step removed friction &mdash; Homebrew handles updates, dependencies, and uninstall for free.
        </div>
      </div>
    </section>

    <footer>
      <p>Built by <a href="https://ataraxy-labs.com">Ataraxy Labs</a></p>
    </footer>
  </div>
</body>
</html>
